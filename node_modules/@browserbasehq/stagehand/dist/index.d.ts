import { Page, BrowserContext } from '@playwright/test';
import { z } from 'zod';
import { Browserbase } from '@browserbasehq/sdk';

interface ChatMessage {
    role: "system" | "user" | "assistant";
    content: string | {
        type: "image_url" | "text";
        image_url?: {
            url: string;
        };
        text?: string;
    }[];
}
interface ChatCompletionOptions {
    model: string;
    messages: ChatMessage[];
    temperature?: number;
    top_p?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
    image?: {
        buffer: Buffer;
        description?: string;
    };
    [key: string]: any;
    response_model?: {
        name: string;
        schema: any;
    };
}
interface LLMClient {
    createChatCompletion(options: ChatCompletionOptions): Promise<any>;
    logger: (message: {
        category?: string;
        message: string;
    }) => void;
}

type LogLine = {
    id?: string;
    category?: string;
    message: string;
    level?: 0 | 1 | 2;
    timestamp?: string;
    auxiliary?: {
        [key: string]: {
            value: string;
            type: "object" | "string" | "html" | "integer" | "float" | "boolean";
        };
    };
};

type AvailableModel = "gpt-4o" | "gpt-4o-mini" | "gpt-4o-2024-08-06" | "claude-3-5-sonnet-latest" | "claude-3-5-sonnet-20241022" | "claude-3-5-sonnet-20240620";
declare class LLMProvider {
    private modelToProviderMap;
    private logger;
    private enableCaching;
    private cache;
    constructor(logger: (message: LogLine) => void, enableCaching: boolean);
    cleanRequestCache(requestId: string): void;
    getClient(modelName: AvailableModel, requestId: string): LLMClient;
}

declare class Stagehand {
    private llmProvider;
    private observations;
    page: Page;
    context: BrowserContext;
    private env;
    private apiKey;
    private projectId;
    private verbose;
    private debugDom;
    private defaultModelName;
    private headless;
    private logger;
    private externalLogger?;
    private domSettleTimeoutMs;
    private browserBaseSessionCreateParams?;
    private enableCaching;
    private variables;
    private actHandler;
    private browserbaseResumeSessionID?;
    constructor({ env, apiKey, projectId, verbose, debugDom, llmProvider, headless, logger, browserBaseSessionCreateParams, domSettleTimeoutMs, enableCaching, browserbaseResumeSessionID, }?: {
        env: "LOCAL" | "BROWSERBASE";
        apiKey?: string;
        projectId?: string;
        verbose?: 0 | 1 | 2;
        debugDom?: boolean;
        llmProvider?: LLMProvider;
        headless?: boolean;
        logger?: (message: LogLine) => void;
        domSettleTimeoutMs?: number;
        browserBaseSessionCreateParams?: Browserbase.Sessions.SessionCreateParams;
        enableCaching?: boolean;
        browserbaseResumeSessionID?: string;
    });
    init({ modelName, domSettleTimeoutMs, }?: {
        modelName?: AvailableModel;
        domSettleTimeoutMs?: number;
    }): Promise<{
        debugUrl: string;
        sessionUrl: string;
    }>;
    initFromPage(page: Page, modelName?: AvailableModel): Promise<{
        context: BrowserContext;
    }>;
    private pending_logs_to_send_to_browserbase;
    private is_processing_browserbase_logs;
    log(logObj: LogLine): void;
    private _run_browserbase_log_processing_cycle;
    private _log_to_browserbase;
    private _waitForSettledDom;
    private startDomDebug;
    private cleanupDomDebug;
    private _recordObservation;
    private _extract;
    private _observe;
    act({ action, modelName, useVision, variables, domSettleTimeoutMs, }: {
        action: string;
        modelName?: AvailableModel;
        useVision?: "fallback" | boolean;
        variables?: Record<string, string>;
        domSettleTimeoutMs?: number;
    }): Promise<{
        success: boolean;
        message: string;
        action: string;
    }>;
    extract<T extends z.AnyZodObject>({ instruction, schema, modelName, domSettleTimeoutMs, }: {
        instruction: string;
        schema: T;
        modelName?: AvailableModel;
        domSettleTimeoutMs?: number;
    }): Promise<z.infer<T>>;
    observe(options?: {
        instruction?: string;
        modelName?: AvailableModel;
        useVision?: boolean;
        domSettleTimeoutMs?: number;
    }): Promise<{
        selector: string;
        description: string;
    }[]>;
}

export { Stagehand };
